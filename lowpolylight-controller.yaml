substitutions:
  name: "kids-room-bedlight"
  num_leds: '65'
  max_led_idx: '64'
  gamma_correct: '1.5'

esphome:
  name: ${name}
  project:
    name: "hexalight.lowpoly-butterfly"
    version: "1.0.0"

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  
# Enable Home Assistant API
api:

ota:
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Lowpoly-Butterfly"
    password: !secret ap_password

captive_portal:

switch:
  - platform: restart
    name: "Restart Light"

light:
  - platform: partition
    name: ${name}
    id: lowpoly
    restore_mode: ALWAYS_OFF
    gamma_correct: ${gamma_correct}
    segments:
      - id: right_wing
        from: 0
        to: ${max_led_idx}
      - id: left_wing
        from: 0
        to: ${max_led_idx}
    effects:
      - addressable_lambda:
          name: "Reading Light"
          update_interval: 1s
          lambda: |-
            it.all()= Color(255, 150, 50);
            return;
      - addressable_rainbow:
          name: "Rainbow"
          width: ${num_leds}
      - addressable_lambda:
          name: "Rainbow Segments"
          update_interval: 1ms
          lambda: |-
            static const uint8_t nsegments = 18;
            static const uint8_t speed = 10;

            // Count of LEDs in each of the segments
            static const uint8_t segments[nsegments] = {6, 6, 5, 12, 2, 13, 3, 4, 5,\
                                                        7, 6, 5, 12, 2, 13, 5, 4, 3};
            static uint16_t colors[nsegments];

            if (initial_run) {
              for (int i = 0; i < nsegments; i++) {
                // Initialize to a random color
                colors[i] = (uint16_t)(random_uint32() & 0x0000FFFF);
              }
            }

            ESPHSVColor hsv(0, 240, 255);
            uint16_t start = 0;
            for (uint8_t i = 0; i < nsegments; i++) {
              uint16_t end = start + segments[i] + 1;
              colors[i] = (colors[i] + speed) % 0xFFFF;
              hsv.hue = (colors[i] >> 8) & 0xFF;
              it.range(start, end) = hsv.to_rgb();
              start = end;
            }
            return;
      - addressable_lambda:
          name: "Ice"
          update_interval: 1ms
          lambda: |-
            #define INT_TO_FIXED16(n) (n << 8)
            static const uint8_t nsegments = 18;
            static const uint8_t speed = 2;

            // Count of LEDs in each of the segments
            static const uint8_t segments[nsegments] = {6, 6, 5, 12, 2, 13, 3, 4, 5,\
                                                        7, 6, 5, 12, 2, 13, 5, 4, 3};
            static uint16_t colors[nsegments];
            
            static const uint16_t min_hue = INT_TO_FIXED16(142);
            static const uint16_t hue_range = INT_TO_FIXED16(81);
            static const uint16_t max_hue = min_hue + hue_range;

            if (initial_run) {
              // Initialize colors to orange-ish color, 45 degrees on hue scale,
              // 1/8th of the full range.
              // Assuming colors are represented by fixed point hue value with
              // 8 bits of fractional part, 45 deg would correspond to 0x2000.
              // We do want a bit of jitter around the middle value.
              for (uint8_t i = 0; i < nsegments; i++) {
                uint16_t offset = (random_uint32() & 0xFFFF) % hue_range;
                colors[i] = min_hue + offset;
              }
            }

            ESPHSVColor hsv(0, 240, 255);
            uint16_t start = 0;
            for (uint8_t i = 0; i < nsegments; i++) {
              uint16_t end = start + segments[i] + 1;
              
              colors[i] = (colors[i] + speed) % max_hue;
              if (colors[i] < min_hue) colors[i] = min_hue;
              hsv.hue = (colors[i] >> 8) & UINT8_MAX;
              
              it.range(start, end) = hsv.to_rgb();
              start = end;
            }
            return;
  - platform: fastled_clockless
    gamma_correct: ${gamma_correct}
    restore_mode: ALWAYS_OFF
    rgb_order: GRB
    chipset: WS2813
    pin: GPIO22
    num_leds: ${num_leds}
    name: "Right Wing"
    id: right_wing
    internal: true

  - platform: neopixelbus
    gamma_correct: ${gamma_correct}
    restore_mode: ALWAYS_OFF
    type: GRB
    variant: WS2813
    pin: GPIO23
    num_leds: ${num_leds}
    name: "Left Wing"
    id: left_wing
    internal: true

esp32_touch:
  setup_mode: false
  iir_filter: 15ms
  low_voltage_reference: 0.5V
  high_voltage_reference: 2.7V
  voltage_attenuation: 1.5V

binary_sensor:
  - platform: esp32_touch
    name: "On/Off"
    pin: GPIO32
    threshold: 1150
    filters:
      - delayed_on_off: 50ms
    on_click:
      - min_length: 800ms
        max_length: 5000ms
        then:
          - light.turn_off: lowpoly
      - min_length: 50ms
        max_length: 700ms
        then:
          lambda: |-
            static const int levels = 5;
            static const float brightness_levels[levels] = {0.0, 0.15, 0.45, 0.8, 1.0};

            static int current_level = 0;

            current_level = (current_level + 1) % (levels);

            auto effects = id(lowpoly).get_effects();
            std::string effect_name = id(lowpoly).get_effect_name();
            if (effect_name == "None") {
              effect_name = effects.front()->get_name();
            }

            if (current_level > 0) {
              auto call = id(lowpoly).turn_on();
              float brightness = brightness_levels[current_level];
              call.set_brightness(brightness);
              call.set_effect(effect_name);
              call.perform();
            }
            else {
              auto call = id(lowpoly).turn_off();
              call.perform();
            }
            return;

  - platform: esp32_touch
    name: "Toggle Effect"
    pin: GPIO33
    threshold: 1050
    filters:
      - delayed_on_off: 100ms
    on_click:
    - min_length: 800ms
      max_length: 5000ms
      then:
        - light.turn_off: lowpoly
    - min_length: 50ms
      max_length: 700ms
      then:
        lambda: |-
            auto call = id(lowpoly).turn_on();

            auto effects = id(lowpoly).get_effects();
            std::string name = id(lowpoly).get_effect_name();

            uint8_t i = 0;

            if (name != "None") {
              // There's an effect in progress, move to the next one
              for (auto e : effects) {
                ++i %= effects.size();
                if (e->get_name() == name) {
                  break;
                }
              }
            }

            call.set_effect(effects[i]->get_name());
            call.perform();
            return;
